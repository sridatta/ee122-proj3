#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>

#include <time.h>
#include <sys/time.h>
#include <math.h>

#include "packet.h"
#include "sender.h"
#include "queue.h"

const int NUM_PACKETS = 500;

int main(int argc, char *argv[]){

  if(argc != 6){
    printf("usage: host port R stream_id window_size\n");
    exit(0);
  }

  char *endptr;
  long R = strtol(argv[3], &endptr, 10);
  char *stream_id = argv[4];
  int window_size = strtol(argv[5], NULL, 10);

  if(endptr != (argv[3] + strlen(argv[3]))) {
    fprintf(stderr, "R must be an integer (milliseconds).\n");
    exit(1);
  }


	struct addrinfo* p;
  int send_sock = send_port(argv[1], argv[2], &p);
  int recv_sock = recv_port(NULL, argv[2]);


  printf("Stream id = %s\n", stream_id);
  ee122_packet pkt;
  pkt.R = R;
  pkt.stream = *stream_id;
  printf("pkt.stream = %c\n", pkt.stream);
  pkt.avg_len = 0;
  pkt.window_size = window_size;

  ee122_packet rcv_pkt;

  struct timespec sleep_spec;
  sleep_spec.tv_sec = 0;

  struct timeval curr_time, start_time, last_generated, diff_time;
  gettimeofday(&start_time, NULL);
  gettimeofday(&last_generated, NULL);

  int seq_no = 0;
  int available_window = window_size;

  struct timeval timeouts[window_size+1];
  ee122_packet packets[window_size+1];

  int i;
  struct timeval zero_timeout;
  zero_timeout.tv_usec = 0;
  zero_timeout.tv_sec = 0;

  for(i = 0; i < window_size+1; i++){
    memcpy(&timeouts[i], &zero_timeout, sizeof(zero_timeout));
  }

  bytequeue q;
  bytequeue_init(&q, sizeof(ee122_packet), window_size);

  float rtt = 400*1000;
  char buff[sizeof(ee122_packet)];

  float next_wait = rand_poisson(R);
  printf("next wait: %f\n", next_wait);

  int bytes_read;
  struct sockaddr src_addr;
  int src_len = sizeof(src_addr);
  int last_received = -1;
  unsigned total_attempts = 0;
  unsigned seconds = 0;
  unsigned fuckups = 0;

  while(1){
    gettimeofday(&curr_time, NULL);

    timeval_subtract(&diff_time, &curr_time, &start_time);

    if (diff_time.tv_sec * 1000000 + diff_time.tv_usec > seconds * 1000000) {
      printf("%f,%d\n", rtt, seconds);
      seconds++;
    }
    // Stop sending after 60 seconds
    if(diff_time.tv_sec * 1000000 + diff_time.tv_usec > 60*1000000){ break; }

    // Check timeouts. If timeout reached, retransmit that packet and all following.
    int retransmitting = -1;
    int i;
    for(i=0; i < window_size+1; i++){
      struct timeval timeout = timeouts[i];
      if(timeout.tv_sec == 0 && timeout.tv_usec == 0) continue;

      timeval_subtract(&diff_time, &curr_time, &timeouts[i]);
      if(diff_time.tv_sec * 1000000 + diff_time.tv_usec > rtt){
        retransmitting = i;
        break;
      } 
    }
    
    if(retransmitting != -1){
      i = retransmitting;
      do {
        struct timeval timeout = timeouts[i];
        if(timeout.tv_sec == 0 && timeout.tv_usec == 0) {
          i = (i + 1) % (window_size+1);
          continue;
        }
        //printf("Retransmitting seq_no == %d, stream == %c, rtt == %f\n", packets[i].seq_number, packets[i].stream, rtt);
        // Reset the timeout for this packet and send.
        gettimeofday(&(timeouts[i]), NULL);
        serialize_packet(buff, packets[i]);
        sendto(send_sock, buff, sizeof(packets[i]), 0, p->ai_addr, p->ai_addrlen);
        i = (i + 1) % (window_size+1);
        total_attempts++;
        fuckups++;
      } while (i != retransmitting);
    }

    // Check if new packet should be generated by now
    timeval_subtract(&diff_time, &curr_time, &last_generated);
    if(diff_time.tv_sec * 1000000 + diff_time.tv_usec > next_wait * 1000){
      // Enqueue the packet.
      bytequeue_push(&q, &pkt);
      next_wait = rand_poisson(R);
    }

    // Read from socket. Increase available window for each ack received
    int bytes_read = recvfrom(recv_sock, buff, sizeof(ee122_packet), 0, &src_addr, &src_len);
    if(bytes_read > 0){
      rcv_pkt = deserialize_packet(buff);
      if(rcv_pkt.stream == 'Z' && rcv_pkt.seq_number == (last_received + 1) % (window_size+1)){
        struct timeval timeout_start = rcv_pkt.timestamp;

        // Learn RTT
        timeval_subtract(&diff_time, &curr_time, &timeout_start);
        //printf("RTT difftime, tv_sec == %d, tv_usec == %d\n", diff_time.tv_sec, diff_time.tv_usec); 
        rtt = (0.6 * (diff_time.tv_sec * 1000000 + diff_time.tv_usec)) + 0.4*rtt;

        // Reset this timeout
        timeouts[rcv_pkt.seq_number].tv_usec = 0;
        timeouts[rcv_pkt.seq_number].tv_sec = 0;

        available_window += 1;
        last_received = rcv_pkt.seq_number % (window_size+1);
      }
      else {
        //printf("Received ACK with seq = %d, expecting = %d\n", rcv_pkt.seq_number, (last_received + 1) % window_size);
      }
    }

    // Check available window. If available, dequeue and send a packet.
    if(available_window > 0 && q.filled != 0){
      bytequeue_pop(&q, &pkt);

      total_attempts++;

      pkt.seq_number = (seq_no) % (window_size+1);
      pkt.timestamp = curr_time;
      pkt.total_attempts = total_attempts;
      
      //printf("Sending. Seq_no == %d, stream == %c\n", pkt.seq_number, pkt.stream);
      serialize_packet(buff, pkt);

      //Store the packet into the packets buffer for possible transmission
      memcpy(&packets[pkt.seq_number], &pkt, sizeof(pkt));

      sendto(send_sock, buff, sizeof(pkt), 0, p->ai_addr, p->ai_addrlen);
      pkt = deserialize_packet(buff);
      available_window -= 1;

      // Set this timeout
      gettimeofday(&timeouts[pkt.seq_number], NULL);

      seq_no++;
    }

  }

  printf("Total fuckups: %d. Total total:%d\n", fuckups, total_attempts);

  close(send_sock);
  close(recv_sock);
  exit(0);
}

int recv_port(char* host, char* port) {
  int status;
  int sockfd;

  struct addrinfo hints;
  memset(&hints, 0, sizeof hints);
  hints.ai_family = AF_INET;
  hints.ai_socktype = SOCK_DGRAM;
  hints.ai_flags = AI_PASSIVE;

  struct addrinfo *res, *p;

  if ((status = getaddrinfo(host, port, &hints, &res)) != 0) {
    fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(status));
    exit(1);
  }

  for(p = res; p != NULL; p = p->ai_next) {
    if ((sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
        perror("Error creating router listener socket");
        continue;
    }

    if (bind(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
      close(sockfd);
      perror("Error binding router listener socket");
      continue;
    }

    break;
  }

  if (p == NULL) {
    fprintf(stderr, "router: failed to bind socket\n");
    return -2;
  }

	int flags = fcntl(sockfd, F_GETFL, 0);
	fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);

  return sockfd;
}

int send_port(char* host, char* port, struct addrinfo** pptr) {
  int status;
  int sockfd;

  printf("Generating send socket\n");
  printf("Host = %s, port = %s\n", host, port);

  struct addrinfo hints;
  memset(&hints, 0, sizeof hints);
  hints.ai_family = AF_INET;
  hints.ai_socktype = SOCK_DGRAM;

  struct addrinfo *res, *p;

  if ((status = getaddrinfo(host, port, &hints, &res)) != 0) {
    fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(status));
    exit(1);
  }

  for(p = res; p != NULL; p = p->ai_next) {
    if ((sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
        continue;
    }

    break;
  }

  if(p == NULL){
    fprintf(stderr, "No valid addresses");
    exit(-2);
  }
  printf("p = %d, ", p);

	*pptr = p;
  return sockfd;
}

int timeval_subtract (struct timeval *result, struct timeval *x, struct timeval *y) { 
	/* Perform the carry for the later subtraction by updating y. */
  if (x->tv_usec < y->tv_usec) {
    int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
    y->tv_usec -= 1000000 * nsec;
    y->tv_sec += nsec;
  }
  if (x->tv_usec - y->tv_usec > 1000000) {
    int nsec = (x->tv_usec - y->tv_usec) / 1000000;
    y->tv_usec += 1000000 * nsec;
    y->tv_sec -= nsec;
	}
														      
  /* Compute the time remaining to wait.
     tv_usec is certainly positive. */
  result->tv_sec = x->tv_sec - y->tv_sec;
  result->tv_usec = x->tv_usec - y->tv_usec;

	return x->tv_sec < y->tv_sec;
}


float rand_poisson(long interpacket)
{
  float rateParameter = 1.0/((float) interpacket);
  return -logf(1.0f - (float) random() / (RAND_MAX)) / rateParameter;
}
